---
title: "L-트로미노 타일링 알고리즘 완벽 정복"
date: 2025-10-04 14:30:00 +0900
categories: [Algorithm, Divide-and-Conquer]
tags: [algorithm, recursion, tromino, divide-and-conquer, cpp, backjoon]
math: true
image:
  path: https://meowtivator-blog-image.s3.ap-northeast-2.amazonaws.com/images/2025/10/02/47eb3cda38585edede3c353a632825b1.png
  alt: 트로미노의 두 가지 형태
---

알고리즘 문제를 풀다 보면 가끔 기하학적 직관이 필요한 문제를 만나게 된다. 트로미노 타일링이 바로 그런 문제다. 처음엔 막막했지만, 분할 정복의 아름다움을 깨닫게 해준 문제였다.


## 트로미노란?

**트로미노(Tromino)**는 크기가 같은 정사각형 3개를 변끼리 붙여 만든 다각형이다. 총 두 가지 형태가 존재한다.

![트로미노의 두 가지 형태](https://meowtivator-blog-image.s3.ap-northeast-2.amazonaws.com/images/2025/10/02/47eb3cda38585edede3c353a632825b1.png){: width="500" }
_I-트로미노(왼쪽)와 L-트로미노(오른쪽)_


이 중에서 우리가 다룰 것은 **L-트로미노**다. L-트로미노는 특별한 성질을 가지고 있는데, 바로 재귀적으로 자기 자신을 채워나갈 수 있다는 점이다.


## L-트로미노의 재귀적 성질

L-트로미노의 가장 흥미로운 특징은 **자기 자신을 재귀적으로 L-트로미노 모양을 이용해서 빈 공간 없이 채울 수 있다**는 것이다.

![L-트로미노의 재귀적 구조](https://meowtivator-blog-image.s3.ap-northeast-2.amazonaws.com/images/2025/10/02/eaff8b6c1fab87bf52ebf494afa3d4d7.png){: width="600" }
_더 큰 L-트로미노를 작은 L-트로미노로 채우는 과정_


이 성질을 확장하면, **2^k × 2^k 크기의 정사각형에서 한 칸만 비워두고 나머지를 모두 L-트로미노로 채울 수 있다**는 놀라운 결론에 도달한다.

![2^k × 2^k 정사각형 타일링](https://meowtivator-blog-image.s3.ap-northeast-2.amazonaws.com/images/2025/10/02/506e6086e3b17add0227b7b1102e2fbc.png){: width="600" }
_8×8 정사각형을 L-트로미노로 채운 예시 (한 칸은 구멍)_


> 💡 **핵심 아이디어**: 정사각형을 4등분했을 때, 각 사분면마다 정확히 하나의 구멍이 존재하도록 L-트로미노를 배치하면 재귀적으로 해결할 수 있다.


## 문제 정의: 백준 14601번

이 알고리즘을 적용할 수 있는 대표적인 문제가 [백준 14601번 - 샤워실 바닥 깔기](https://www.acmicpc.net/problem/14601)다.

### 입력
- `k`: 샤워실 크기는 2^k × 2^k
- `x, y`: 배수구의 위치 (1-indexed)

### 주의사항
문제에서 주어지는 좌표계는 일반적인 배열 인덱스와 다르다:
- **x 좌표**: 열(column) → 배열에서는 `y-1`
- **y 좌표**: 아래에서부터 세는 행 → 배열에서는 `size - x`

이 좌표 변환을 놓치면 답이 틀리니 주의해야 한다.


## 알고리즘 해설

### 분할 정복 전략

L-트로미노 타일링은 **분할 정복(Divide and Conquer)** 방식으로 해결한다.

1. **분할**: 2^k × 2^k 정사각형을 4개의 2^(k-1) × 2^(k-1) 사분면으로 나눈다
2. **정복**: 구멍이 없는 3개 사분면의 중심에 L-트로미노 하나를 배치 → 이제 모든 사분면에 구멍이 하나씩 생긴다
3. **재귀**: 각 사분면을 독립적으로 재귀 호출
4. **종료 조건**: 크기가 1×1이 되면 종료


### 사분면 판별 로직

```
사분면 번호:
┌─────┬─────┐
│  0  │  1  │
├─────┼─────┤
│  2  │  3  │
└─────┴─────┘
```

현재 구멍의 위치를 파악해서, **구멍이 없는 3개 사분면의 중심점에 L-트로미노를 배치**한다.


### 핵심 로직 설명

정답 코드의 핵심 부분만 설명하자면:

1. **사분면 판별**:
   - 중심점을 기준으로 구멍이 어느 사분면에 있는지 파악

2. **L-트로미노 배치**:
   - 구멍이 없는 3개 사분면의 중앙 교차점에 하나의 L-트로미노 배치
   - 이제 4개 사분면 모두 구멍이 하나씩 생김

3. **재귀 호출**:
   - 구멍이 원래 있던 사분면: 원래 구멍 좌표 전달
   - 새로 L-트로미노가 배치된 사분면: 배치된 타일 좌표를 구멍으로 전달

## 정답 코드
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int tileNum{1};

void tromino(vector<vector<int>>& board, int top, int left, int size, int holeX, int holeY){
  if(size == 1) return;
  int mid = size / 2;
  int centerX = top+mid;
  int centerY = left+mid;

  int curTile = tileNum++;
  
  int quad = 0;
  // quad
  // 0 1
  // 2 3
  if(holeX < centerX){
    if(holeY < centerY) quad = 0;
    else quad = 1;
  }else{
    if(holeY< centerY) quad = 2;
    else quad = 3;
  }

  if(quad != 0) board[top+mid-1][left+mid-1] = curTile;
  if(quad != 1) board[top+mid-1][left+mid] = curTile;
  if(quad != 2) board[top+mid][left+mid-1] = curTile;
  if(quad != 3) board[top+mid][left+mid] = curTile;

  if(quad == 0) tromino(board, top, left, mid, holeX, holeY);
  else          tromino(board, top, left, mid, top+mid-1, left+mid-1);
  if(quad == 1) tromino(board, top, left+mid, mid, holeX, holeY);
  else          tromino(board, top, left+mid, mid, top+mid-1, left+mid);
  if(quad == 2) tromino(board, top+mid, left, mid, holeX, holeY);
  else          tromino(board, top+mid, left, mid, top+mid, left+mid-1);
  if(quad == 3) tromino(board, top+mid, left+mid, mid, holeX, holeY);
  else          tromino(board, top+mid, left+mid, mid, top+mid, left+mid);

}

int main(){
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int k, x, y;
  cin >> k >> x >> y;
  int size = pow(2,k);
  vector<vector<int>> board(size, vector<int>(size, 0));
  int holeX = size-y, holeY = x-1;
  board[holeX][holeY] = -1;
  tromino(board, 0, 0, size, holeX, holeY);

  for(int i{0}; i <size; ++i){
    for(int j{}; j<size; ++j){
      cout << board[i][j] << (j == size - 1 ? "\n" : " ");
    }
  }

  return 0;
}
```

## 시간 복잡도

전체 타일 개수는 (2^k × 2^k - 1) / 3 = O(4^k)이고, 각 타일을 한 번씩만 배치하므로 **시간 복잡도는 O(4^k)**다.

재귀 깊이는 k이며, 각 단계에서 4개의 재귀 호출이 발생한다:

```
T(n) = 4T(n/2) + O(1)
     = O(n²)  (n = 2^k인 경우)
```


## 배운 점

처음에는 "어떻게 재귀로 타일을 깔지?"라는 생각에 막막했다. 하지만 **"각 사분면에 구멍을 하나씩 만들어주면 된다"**는 핵심 아이디어를 깨닫고 나니 코드가 술술 나왔다.

분할 정복 문제를 풀 때는 다음을 명심해야 한다:
- **부분 문제가 원래 문제와 같은 구조**를 가지도록 만들기
- **재귀 호출 전에 필요한 전처리** 수행하기
- **종료 조건**을 명확히 하기


다음에는 이런 기하학적 분할 정복 문제를 더 찾아봐야겠다.


## 참고 자료

- [백준 14601번 - 샤워실 바닥 깔기](https://www.acmicpc.net/problem/14601)
- [Tromino Puzzle - Wikipedia](https://en.wikipedia.org/wiki/Tromino)

---

_이 글이 도움이 됐다면 댓글로 피드백을 남겨주세요!_